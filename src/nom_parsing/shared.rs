use std::{collections::HashSet, fmt::Debug, str::FromStr};

use nom::{branch::alt, bytes::complete::{tag, take_till, take_until, take_while}, character::complete::{multispace0, space1, u8}, combinator::{cut, opt, recognize}, error::{context, ErrorKind, ParseError}, multi::{count, many0, separated_list1}, sequence::{delimited, separated_pair, terminated}, AsChar, Compare, CompareResult, Parser};
use nom_language::error::VerboseError;

use crate::{enums::{Base, BaseNameVariants, Distance, FieldingErrorType, FoulType, HitDestination, HitType, Position, StrikeType, TopBottom}, parsed_event::{BaseSteal, Play, PositionedPlayer, RunnerAdvance, RunnerOut}, Game};

pub(super) type Error<'a> = VerboseError<&'a str>;
pub(super) type IResult<'a, I, O> = nom::IResult<I, O, Error<'a>>;

/// Context name for parsing a team name. Errors here possibly caused by team name changes
pub const EXTRACT_TEAM_NAME:&str = "team_name";

/// Context name for parsing a fielder name. Errors here possibly caused by relegation introducing a player midgame
pub const EXTRACT_PLAYER_NAME:&str = "player_name";

/// Context necessary for parsing. The 'output lifetime is linked to ParsedEvents parsed in this context.
#[derive(Clone, Debug)]
pub struct ParsingContext<'output> {
    pub player_names: HashSet<&'output str>,
    pub team_names: HashSet<&'output str>,
    pub game: &'output Game
}
impl<'output> ParsingContext<'output> {
    pub fn new(game: &'output Game) -> Self {
        let mut team_names = HashSet::new();
        team_names.insert(game.away_team_name.as_str());
        team_names.insert(game.home_team_name.as_str());
        Self {
            player_names: HashSet::new(),
            team_names,
            game
        }
    }
}

#[allow(dead_code)]
pub(super) fn debugger<'output, E: ParseError<&'output str> + Debug, F: Parser<&'output str, Output = O, Error = E>, O: Debug>(parser: F) -> impl Parser<&'output str, Output =  O, Error = E> {
    let mut r = parser;
    move |i| {
        match r.parse(i) {
            r @ Err(_) => dbg!(r),
            o => o 
        }
    }
}

/// Discare whitespace around a child parser
pub(super) fn strip<'output, E: ParseError<&'output str>, F: Parser<&'output str, Output = O, Error = E>, O>(parser: F) -> impl Parser<&'output str, Output =  O, Error = E> {
    delimited(multispace0, parser, multispace0)
}

/// Discards \<strong>\</strong> tags and whitespace from around the child parser.
pub(super) fn bold<'output, E: ParseError<&'output str>, F: Parser<&'output str, Output = O, Error = E>, O>(parser: F) -> impl Parser<&'output str, Output =  O, Error = E> {
    strip(delimited(tag("<strong>"), parser, tag("</strong>")))
}
/// Discards whitespace and a terminating full stop from around the child parser.
pub(super) fn sentence<'output, E: ParseError<&'output str>, F: Parser<&'output str, Output = O, Error = E>, O>(parser: F) -> impl Parser<&'output str, Output =  O, Error = E> {
    strip(terminated(parser, tag(".")))
}

/// Discards whitespace and a terminating exclamation mark from around the child parser.
pub(super) fn exclamation<'output, E: ParseError<&'output str>, F: Parser<&'output str, Output = O, Error = E>, O>(parser: F) -> impl Parser<&'output str, Output =  O, Error = E> {
    strip(terminated(parser, tag("!")))
}

/// A single group of alphanumeric characters, discarding whitespace on either side
pub(super) fn word(s: &str) -> IResult<&str, &str> {
    strip(take_while(AsChar::is_alphanum)).parse(s)
}

/// As the tag combinator, but discards whitespace on either side.
pub(super) fn s_tag<'output, Error: ParseError<&'output str> + Debug>(tag_str: &'output str) -> impl Parser<&'output str, Output = &'output str, Error = Error> {
    strip(tag(tag_str))
}

/// n groups of space-separated aphamuric characters, outputed as a single str. Discards whitespace on either side
pub(super) fn words<'output>(n: usize) -> impl Parser<&'output str, Output = &'output str, Error = Error<'output>> {
    strip(recognize((take_while(AsChar::is_alphanum), count((space1, take_while(AsChar::is_alphanum)), n-1))))
}

/// A single player's name, obtained by matching the known player names in the context.
/// 
/// Can fail - usually when a player who wasn't in the lineup fields (e.g. because they were generated by a mid-game Relegation).
pub(super) fn player_name<'output, 'parse>(parsing_context: &'parse ParsingContext<'output>) -> impl Parser<&'output str, Output = &'output str, Error = Error<'output>> + 'parse {
    context(EXTRACT_PLAYER_NAME, strip(move |i: &'output str| {
        for name in parsing_context.player_names.iter() {
            let name_len = name.len();
            if i.compare(*name) == CompareResult::Ok {
                return Ok((&i[name_len..], &i[..name_len]))
            }
        }
        IResult::Err(nom::Err::Error(VerboseError::from_error_kind(i, ErrorKind::Tag)))
    }))
}

/// A type of hit, e.g. "ground ball"
pub(super) fn hit_type(i: &str) -> IResult<&str, HitType> {
    alt((
        words(2).map_res(HitType::try_from),
        word.map_res(HitType::try_from),
    )).parse(i)
}

/// Verb names for hit types, e.g. "pops"
pub(super) fn hit_type_verb_name(i: &str) -> IResult<&str, HitType> {
    word.map_opt(|word| match word {
        "grounds" => Some(HitType::GroundBall),
        "flies" => Some(HitType::FlyBall),
        "lines" => Some(HitType::LineDrive),
        "pops" => Some(HitType::Popup),
        _ => None
    }).parse(i)
}

/// A destination for a hit, e.g. "the shortstop"
pub(super) fn destination(i: &str) -> IResult<&str, HitDestination> {
    words(2).map_res(HitDestination::try_from)
        .parse(i)
}

/// The acronym for a player's position, e.g. "SP"
pub(super) fn position(i: &str) -> IResult<&str, Position> {
    word.map_res(Position::try_from).parse(i)
}

/// A foul type, e.g. "Ball"
pub(super) fn foul_type(i: &str) -> IResult<&str, FoulType> {
    word.map_res(FoulType::try_from).parse(i)
}

/// Top or bottom of the inning, e.g. "top"
pub(super) fn top_or_bottom(i: &str) -> IResult<&str, TopBottom> {
    word.map_res(TopBottom::try_from).parse(i)
}

/// A strike type, e.g. "Swinging"
pub(super) fn strike_type(i: &str) -> IResult<&str, StrikeType> {
    word.map_res(StrikeType::try_from).parse(i)
}

/// A list of fielders involved in a catch, e.g. "P Niblet Hornsby to 1B Geo Kerr to 3B Joffrey Nishida"
pub(super) fn fielders<'output, 'parse>(parsing_context: &'parse ParsingContext<'output>) -> impl Parser<&'output str, Output = Vec<PositionedPlayer<&'output str>>, Error = Error<'output>> + 'parse{
    terminated(separated_list1(s_tag("to"), positioned_player(parsing_context)),
            opt(s_tag("unassisted")))
}

/// A team's emoji and name, e.g. "\ud83d\udc2f Antioch Royal Tigers".
pub(super) fn team_emoji_and_name<'output, 'parse>(parsing_context: &'parse ParsingContext<'output>) -> impl Parser<&'output str, Output = (&'output str, &'output str), Error = Error<'output>> + 'parse {
    (strip(take_till(AsChar::is_space)), team_name(parsing_context))
}

/// A single team's name, obtained by matching the known team names in the context. e.g. "Antioch Royal Tigers"
pub(super) fn team_name<'output, 'parse>(parsing_context: &'parse ParsingContext<'output>) -> impl Parser<&'output str, Output = &'output str, Error = Error<'output>> + 'parse {
    context(EXTRACT_TEAM_NAME,strip(move |i: &'output str| {
        for name in parsing_context.team_names.iter() {
            let name_len = name.len();
            if i.compare(*name) == CompareResult::Ok {
                return Ok((&i[name_len..], &i[..name_len]))
            }
        }
        IResult::Err(nom::Err::Error(VerboseError::from_error_kind(i, ErrorKind::Tag)))
    }))
}

/// A position + a player's name. If position found assume name should be findable, and Fail if its not.
pub(super) fn positioned_player<'output, 'parse>(parsing_context: &'parse ParsingContext<'output>) -> impl Parser<&'output str, Output = PositionedPlayer<&'output str>, Error = Error<'output>> + 'parse {
    (position, context(EXTRACT_PLAYER_NAME, cut(player_name(parsing_context)))).map(|(position ,player)| PositionedPlayer { name: player, position })
}

/// A distance a batter runs, e.g. "singles"
pub(super) fn distance(i: &str) -> IResult<&str, Distance> {
    word.map_res(Distance::from_str).parse(i)
}

/// A base, e.g. "first". Case insensitive
pub(super) fn base(i: &str) -> IResult<&str, Base> {
    word.map_res(Base::try_from).parse(i)
}

/// Sometimes bases get called e.g. "1B" instead.
pub(super) fn base_name_variants(i: &str) -> IResult<&str, BaseNameVariants> {
    alt((
        words(2).map_res(BaseNameVariants::try_from),
        word.map_res(BaseNameVariants::try_from),
    )).parse(i)
}

/// A type fielding error e.g. "throwing". Case insensitive
pub(super) fn fielding_error_type(i: &str) -> IResult<&str, FieldingErrorType> {
    word.map_res(FieldingErrorType::from_str).parse(i)
}

/// A single instance of an out, e.g. "Franklin Shoebill out at home."
pub(super) fn out_sentence<'output, 'parse>(parsing_context: &'parse ParsingContext<'output>) -> impl Parser<&'output str, Output = RunnerOut<&'output str>, Error = Error<'output>> + 'parse {
    sentence((
        terminated(player_name(parsing_context), s_tag("out at")),
        base_name_variants
    ))
    .map(|(player, base)| RunnerOut { runner: player, base })
}

/// A single instance of an score, e.g. "<bold>Franklin Shoebill scores!</bold>"
pub(super) fn scores_sentence<'output, 'parse>(parsing_context: &'parse ParsingContext<'output>) -> impl Parser<&'output str, Output = &'output str, Error = Error<'output>> + 'parse {
    bold(exclamation(terminated(player_name(parsing_context), s_tag("scores"))))
}

// A single instance of a runner advancing, e.g. "Franklin shoebill to third base."
pub fn runner_advance_sentence<'output, 'parse>(parsing_context: &'parse ParsingContext<'output>)-> impl Parser<&'output str, Output = RunnerAdvance<&'output str>, Error = Error<'output>> + 'parse {
    sentence((player_name(parsing_context), delimited(s_tag("to"), base, s_tag("base"))))
    .map(|(runner, base)| RunnerAdvance {runner, base})
}

/// The suffix of an ordinal, e.g. the "th" of 4th 
pub(super) fn ordinal_suffix(i: &str) -> IResult<&str, &str> {
    alt((
        tag("th"),
        tag("rd"),
        tag("nd"),
        tag("st"),
    )).parse(i)
}

/// 
pub(super) fn scores_and_advances<'output, 'parse>(parsing_context: &'parse ParsingContext<'output>) -> impl Parser<&'output str, Output = (Vec<&'output str>, Vec<RunnerAdvance<&'output str>>), Error = Error<'output>> + 'parse {
    (
        many0(scores_sentence(parsing_context)),
        many0(runner_advance_sentence(parsing_context))
    )
}

pub(super) fn play_sentence<'output, 'parse>(parsing_context: &'parse ParsingContext<'output>) -> impl Parser<&'output str, Output = Play<&'output str>, Error = Error<'output>> + 'parse {
    alt((
        out_sentence(parsing_context)
            .map(|out| Play::Out { out }),
        sentence(separated_pair(fielding_error_type, s_tag("error by"), player_name(parsing_context)))
            .map(|(error, fielder)| Play::Error { fielder, error })
    ))
}

// e.g. ""
pub(super) fn base_steal_sentence<'output, 'parse>(parsing_context: &'parse ParsingContext<'output>) -> impl Parser<&'output str, Output = BaseSteal<&'output str>, Error = Error<'output>> + 'parse {
    let home_steal = bold(exclamation(terminated(player_name(parsing_context), s_tag("steals home"))))
    .map(|runner| BaseSteal { runner, base:Base::Home, caught:false });

    let successful_steal = exclamation((player_name(parsing_context), delimited(s_tag("steals"), base, s_tag("base"))))
    .map(|(runner, base)| BaseSteal {runner, base, caught: false });

    let caught_stealing = sentence((player_name(parsing_context), delimited(s_tag("is caught stealing"), base, opt(s_tag("base")))))
    .map(|(runner, base)| BaseSteal {runner, base, caught: true });

    alt((
        home_steal,
        successful_steal,
        caught_stealing
    ))
}

pub(super) fn score_update_sentence<'output>(i: &'output str) -> IResult<'output, &'output str, (u8, u8)> {
    sentence(strip(separated_pair(u8, s_tag("-"), u8)))
    .parse(i)
}

pub(super) fn switch_pitcher_sentences<'output>(i: &'output str) -> IResult<'output, &'output str, ((Position, &'output str), (Position, &'output str))> {
    (
        sentence(terminated((position, take_until(" is leaving the game")), s_tag("is leaving the game"))), 
        sentence(terminated((position, take_until(" takes the mound")), s_tag("takes the mound")))
    )
    .parse(i)
}
